#!/usr/bin/env python3
"""
Read and render a udif file.

usage:
    run-tests [options] [<filename>...]

options:
    -e <encoder>, --encoder=<encoder>  external encoder to test
    -d <decoder>, --decoder=<decoder>  external decoder to test
    -v, --verbose                      list the tests as they are being run

If no file names are given, all tests are run.  My specify either 'valid' or 
'invalid' as filename to run just those tests.

If an encoder or decoder is given, it should be the path to a program that the 
expected data on stdin, outputs on stdout, and exits with a status of 0 if it 
succeeded and 1 if it failed.  An external encoder is expected to take json on 
its input and produce a udif equivalent on its output.  An external decoder 
takes udif on its input and output json on its output.
"""

from docopt import docopt
from inform import (
    Inform, comment, display, error, os_error, is_str, errors_accrued, plural
)
from shlib import to_path, lsf, Run, set_prefs as shlib_set_prefs
import json
import udif

cmdline = docopt(__doc__)
args = cmdline['<filename>']
encoder = cmdline['--encoder']
decoder = cmdline['--decoder']
if not encoder or decoder:
    encoder = decoder = True
shlib_set_prefs(use_inform=True)

# gather tests
valid_testcases = [
    case.with_suffix('')
    for case in list(lsf('valid', select='*.udif')) + list(lsf('valid', select='*.json'))
]
invalid_testcases = [
    case.with_suffix('')
    for case in list(lsf('invalid', select='*.udif')) + list(lsf('invalid', select='*.json'))
]
testcases = set()
for arg in args:
    if arg == 'valid':
        testcases |= valid_testcases
    elif arg == 'invalid':
        testcases |= invalid_testcases
    else:
        testcases.add(to_path(arg).with_suffix(''))
if not testcases:
    testcases = set(valid_testcases + invalid_testcases)

def load_json_file(case):
    json_path = case.with_suffix('.json')
    json_content = json_path.read_text()
    data = json.loads(json_content)
    return data

def load_udif_file(case):
    udif_path = case.with_suffix('.udif')
    udif_content = udif_path.read_text()
    data = udif.loads(udif_content, udif_path)
    return data

def run_internal_encoder_test(case):
    given_data = load_json_file(case)
    try:
        udif_content = udif.dumps(given_data)
    except udif.Error:
        return 'error'
    extracted_data = udif.loads(udif_content)
    success = extracted_data == given_data
    return None if success else 'mismatch'

def run_internal_decoder_test(case):
    try:
        extracted_data = load_udif_file(case)
    except udif.Error:
        return 'error'
    expected_data = load_json_file(case)
    success = extracted_data == expected_data
    return None if success else 'mismatch'

def run_external_encoder_test(encoder, path):
    given_json_content = path.with_suffix('.json').read_text()
    process = Run(encoder, stdin=given_json_content, modes='sOEW1')
    if process.status != 0:
        return 'error'
    udif_content = process.stdout
    extracted_data = udif.loads(udif_content)
    success = extracted_data == given_data
    return None if success else 'mismatch'

def run_external_decoder_test(decoder, path):
    given_udif_content = path.read_text()
    process = Run(encoder, stdin=given_udif_content, modes='sOEW1')
    if process.status != 0:
        return error
    json_content = process.stdout
    extracted_data = json.loads(json_content)
    expected_data = load_json_file(path)
    success = extracted_data == expected_data
    return None if success else 'mismatch'

tests = 0
with Inform(verbose=cmdline['--verbose']):
    for case in sorted(testcases):
        try:
            if encoder and case.with_suffix('.json').exists():
                comment(case.with_suffix('.json'), 'encoder')
                tests += 1
                if is_str(encoder):
                    fails = run_external_encoder_test(encoder, case)
                else:
                    fails = run_internal_encoder_test(case)
                if case in valid_testcases:
                    if fails:
                        error(f'encoder fails due to {fails}.', culprit=case)
                else:
                    assert case in invalid_testcases
                    if fails != 'error':
                        error('encoder fails to fail.', culprit=case)
            if decoder and case.with_suffix('.udif').exists():
                comment(case.with_suffix('.udif'), 'decoder')
                tests += 1
                if is_str(decoder):
                    fails = run_external_decoder_test(decoder, case)
                else:
                    fails = run_internal_decoder_test(case)
                if case in valid_testcases:
                    if fails:
                        error(f'decoder fails due to {fails}.', culprit=case)
                else:
                    assert case in invalid_testcases
                    if fails != 'error':
                        error('decoder fails to fail.', culprit=case)
        except OSError as e:
            error(os_error(e))
        except udif.Error as e:
            e.report()
        except json.JSONDecodeError as e:
            error(e)

    failures = errors_accrued()
    status = 'FAIL' if failures else 'PASS'
    display(f'{status}: {plural(failures):# failure} in {plural(tests):# test}.')
