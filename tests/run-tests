#!/usr/bin/env python3
"""
Test NestedText encoder and decoder.

usage:
    run-tests [options] [<filename>...]

options:
    -e <encoder>, --encoder=<encoder>  external encoder to test
    -d <decoder>, --decoder=<decoder>  external decoder to test
    -v, --verbose                      list the tests as they are being run

If no file names are given, all tests are run.  My specify either 'valid' or 
'invalid' as filename to run just those tests.

If an encoder or decoder is given, it should be the path to a program that the 
expected data on stdin, outputs on stdout, and exits with a status of 0 if it 
succeeded and 1 if it failed.  An external encoder is expected to take JSON  on 
its input and produce a NestedText equivalent on its output.  An external 
decoder takes NestedText on its input and output JSON  on its output.
"""

from docopt import docopt
from inform import (
    Inform, comment, display, error, os_error, is_str, errors_accrued, plural
)
from shlib import to_path, lsf, Run, set_prefs as shlib_set_prefs
import json
import nestedtext

cmdline = docopt(__doc__)
args = cmdline['<filename>']
encoder = cmdline['--encoder']
decoder = cmdline['--decoder']
if not encoder or decoder:
    encoder = decoder = True
shlib_set_prefs(use_inform=True)

# gather tests
valid_testcases = [
    case.with_suffix('')
    for case in list(lsf('valid', select='*.nxt')) + list(lsf('valid', 
select='*.json'))
]
invalid_testcases = [
    case.with_suffix('')
    for case in list(lsf('invalid', select='*.nxt')) + list(lsf('invalid', 
select='*.json'))
]
testcases = set()
for arg in args:
    if arg == 'valid':
        testcases |= valid_testcases
    elif arg == 'invalid':
        testcases |= invalid_testcases
    else:
        testcases.add(to_path(arg).with_suffix(''))
if not testcases:
    testcases = set(valid_testcases + invalid_testcases)

def load_json_file(case):
    json_path = case.with_suffix('.json')
    json_content = json_path.read_text()
    data = json.loads(json_content)
    return data

def load_nxt_file(case):
    nxt_path = case.with_suffix('.nxt')
    nxt_content = nxt_path.read_text()
    data = nestedtext.loads(nxt_content, nxt_path)
    return data

def run_internal_encoder_test(case):
    given_data = load_json_file(case)
    try:
        nxt_content = nestedtext.dumps(given_data)
    except nestedtext.NestedTextError:
        return 'error'
    extracted_data = nestedtext.loads(nxt_content)
    success = extracted_data == given_data
    return None if success else 'mismatch'

def run_internal_decoder_test(case):
    try:
        extracted_data = load_nxt_file(case)
    except nestedtext.NestedTextError:
        return 'error'
    expected_data = load_json_file(case)
    success = extracted_data == expected_data
    return None if success else 'mismatch'

def run_external_encoder_test(encoder, path):
    given_json_content = path.with_suffix('.json').read_text()
    process = Run(encoder, stdin=given_json_content, modes='sOEW1')
    if process.status != 0:
        return 'error'
    nxt_content = process.stdout
    extracted_data = nestedtext.loads(nxt_content)
    success = extracted_data == given_data
    return None if success else 'mismatch'

def run_external_decoder_test(decoder, path):
    given_nxt_content = path.read_text()
    process = Run(encoder, stdin=given_nxt_content, modes='sOEW1')
    if process.status != 0:
        return error
    json_content = process.stdout
    extracted_data = json.loads(json_content)
    expected_data = load_json_file(path)
    success = extracted_data == expected_data
    return None if success else 'mismatch'

tests = 0
with Inform(verbose=cmdline['--verbose']):
    for case in sorted(testcases):
        try:
            src_file = case.with_suffix('.json')
            if encoder and src_file.exists():
                comment(src_file, 'encoder')
                tests += 1
                if is_str(encoder):
                    fails = run_external_encoder_test(encoder, case)
                else:
                    fails = run_internal_encoder_test(case)
                if case in valid_testcases:
                    if fails:
                        error(f'encoder fails due to {fails}.', culprit=src_file)
                else:
                    assert case in invalid_testcases
                    if fails != 'error':
                        error('encoder fails to fail.', culprit=src_file)

            src_file = case.with_suffix('.nxt')
            if decoder and src_file.exists():
                comment(src_file, 'decoder')
                tests += 1
                if is_str(decoder):
                    fails = run_external_decoder_test(decoder, case)
                else:
                    fails = run_internal_decoder_test(case)
                if case in valid_testcases:
                    if fails:
                        error(f'decoder fails due to {fails}.', culprit=src_file)
                else:
                    assert case in invalid_testcases
                    if fails != 'error':
                        error('decoder fails to fail.', culprit=src_file)
        except OSError as e:
            error(os_error(e))
        except nestedtext.NestedTextError as e:
            e.report()
        except json.JSONDecodeError as e:
            error(e)

    failures = errors_accrued()
    status = 'FAIL' if failures else 'PASS'
    display(f'{status}: {plural(failures):# failure} in {plural(tests):# test}.')
